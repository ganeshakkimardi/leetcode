| Question                                                         | Details                                                                                                                                                                                                                                        |
| ---------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **LC169 – Majority Element**                                     | **Boyer–Moore Majority Vote Algorithm** → Maintain `count` and `number`. If the current number is the same, increment `count`. If different, decrement `count`. If `count` becomes `0`, update `number` to the current element.                |
| **LC229 – Majority Element II**                                  | At most **2 elements** can be in the answer. Use a map to count all numbers. If `count > threshold (length / 3)`, add it to the result array and return the array.                                                                             |
| **LC283 – Move Zeroes**                                          | Use `left` and `right` pointers. Iterate using `right`. If `nums[right] != 0`, swap `left` and `right`, then increment `left`.                                                                                                                 |
| **LC287 – Find the Duplicate Number**                            | Get index `ind`. For each iteration, update `nums[ind] = -nums[ind]`. If `nums[ind] < 0`, return `ind`.                                                                                                                                        |
| **LC189 – Rotate Array**                                         | Use extra array logic: `rotated[(i + k) % len] = nums[i];`                                                                                                                                                                                     |
| **LC414 – Third Maximum Number**                                 | Sort the array. If the count of unique elements is `3`, return `nums[i-1]`; otherwise, return `nums[n-1]`.                                                                                                                                     |
| **LC55 – Jump Game**                                             | Start from the second last index. Check if `i + nums[i] >= goal`. If yes, update `goal = i`. Finally, return `goal == 0`.                                                                                                                      |
| **LC46 – Permutations**                                          | Use DFS (backtracking) with a `used` set to track visited elements.                                                                                                                                                                            |
| **LC4 – Median of Two Sorted Arrays**                            | Take a new array, add both arrays to it, sort it, and return the middle element or `(mid + mid+1) / 2`.                                                                                                                                        |
| **LC33 – Search in Rotated Sorted Array**                        | Apply binary search with conditions based on sorted halves.                                                                                                                                                                                    |
| **LC74 – Search a 2D Matrix**                                    | Treat the matrix as a 1D array. Use `i = 0`, `j = length - 1`. If `matrix[i][j] < target`, increment `i`; else decrement `j`.                                                                                                                  |
| **LC153 – Find Minimum in Rotated Sorted Array**                 | Use binary search to find the pivot (minimum element).                                                                                                                                                                                         |
| **LC704 – Binary Search**                                        | Divide and conquer approach. If not found, update `high = mid - 1` or `low = mid + 1`.                                                                                                                                                         |
| **LC875 – Koko Eating Bananas**                                  | Apply binary search on eating speed.                                                                                                                                                                                                           |
| **LC121 – Best Time to Buy and Sell Stock I**                    | Track minimum price and calculate max profit using `Math.max(maxProfit, prices[i] - minPrice)`.                                                                                                                                                |
| **LC122 – Best Time to Buy and Sell Stock II**                   | Sum all positive differences. If `prices[i] > prices[i-1]`, then `profit += prices[i] - prices[i-1]`.                                                                                                                                          |
| **LC1 – Two Sum**                                                | Use a hashmap to store seen numbers and their indices.                                                                                                                                                                                         |
| **LC13 – Roman to Integer**                                      | Add all Roman numeral values using a map and subtract when a smaller value precedes a larger value.                                                                                                                                            |
| **LC49 – Group Anagrams**                                        | Use sorted string as the key in a map and return the map values.                                                                                                                                                                               |
| **LC128 – Longest Consecutive Sequence**                         | Start counting only from sequence heads.                                                                                                                                                                                                       |
| **LC187 – Repeated DNA Sequences**                               | Use sliding window + set to track repeated sequences.                                                                                                                                                                                          |
| **LC217 – Contains Duplicate**                                   | Use a set. If `set.contains(i)` return true; else false.                                                                                                                                                                                       |
| **LC347 – Top K Frequent Elements**                              | Use a heap or bucket sort with a priority queue.                                                                                                                                                                                               |
| **LC21 – Merge Two Sorted Lists**                                | Iteratively merge by comparing `list1.val` and `list2.val`.                                                                                                                                                                                    |
| **LC143 – Reorder List**                                         | Split list using fast/slow pointers, reverse the second half, then merge first list with reversed second list.                                                                                                                                 |
| **LC206 – Reverse Linked List**                                  | `java\nIterative pointer reversal:\nwhile (head != null) {\n    ListNode temp = head.next;\n    head.next = node;\n    node = head;\n    head = temp;\n}\nreturn node;\n`                                                                      |
| **LC19 – Remove Nth Node From End of List**                      | Use two pointers. Move `fast` pointer `n` times, then move both `slow` and `fast`. When `fast` becomes null, remove the node pointed by `slow`.                                                                                                |
| **LC138 – Copy List With Random Pointer**                        | Use hashmap or node-copying technique to clone nodes and random pointers.                                                                                                                                                                      |
| **LC981 – Time Based Key-Value Store**                           | Store key with list of `(timestamp, value)` pairs and use binary search on timestamps.                                                                                                                                                         |
| **LC7 – Reverse Integer**                                        | Reverse digits while handling overflow cases.                                                                                                                                                                                                  |
| **LC739 – Daily Temperatures**                                   | Use a decreasing stack. Store indices and pop while `temperatures[stack.peek()] < temperatures[i]`.                                                                                                                                            |
| **LC8 – String to Integer (atoi)**                               | Trim spaces, handle sign, and manage overflow.                                                                                                                                                                                                 |
| **LC238 – Product of Array Except Self**                         | Use prefix and suffix product arrays.                                                                                                                                                                                                          |
| **LC6 – Zigzag Conversion**                                      | Simulate zigzag row traversal.                                                                                                                                                                                                                 |
| **LC3 – Longest Substring Without Repeating Characters**         | Expand sliding window and shrink when repetition occurs.                                                                                                                                                                                       |
| **LC424 – Longest Repeating Character Replacement**              | Sliding window approach while tracking max frequency.                                                                                                                                                                                          |
| **LC567 – Permutation in String**                                | Use frequency count and sliding window.                                                                                                                                                                                                        |
| **LC76 – Minimum Window Substring**                              | `java\nint[] arr = new int[128];\nRead all chars from t into arr.\nIterate s:\nif (arr[s[end++]]-- > 0) count--;\nwhile (count == 0) {\n    if (end - start < minLen) update minLen;\n}\n`                                                     |
| **LC1423 – Maximum Points You Can Obtain From Cards**            | Use sliding window on total sum and subtract minimum subarray.                                                                                                                                                                                 |
| **LC1461 – Check If String Contains All Binary Codes of Size K** | Use a set and add `s.substring(i, i + k)`. If `set.size() == 2^k`, return true.                                                                                                                                                                |
| **LC1876 – Substrings of Size Three With Distinct Characters**   | Use left and right pointers with a map. If window size is 3 and map size is 3, increment count.                                                                                                                                                |
| **LC2461 – Maximum Sum of Distinct Subarrays With Length K**     | Sliding window using set and sum tracking.                                                                                                                                                                                                     |
| **LC20 – Valid Parentheses**                                     | Use stack to match brackets.                                                                                                                                                                                                                   |
| **LC150 – Evaluate Reverse Polish Notation**                     | Use stack to store operands.                                                                                                                                                                                                                   |
| **LC155 – Min Stack**                                            | Use auxiliary stack or store `(value, min)` pairs.                                                                                                                                                                                             |
| **LC853 – Car Fleet**                                            | Sort cars by position and process using stack logic.                                                                                                                                                                                           |
| **LC14 – Longest Common Prefix**                                 | Compare characters across all strings.                                                                                                                                                                                                         |
| **LC12 – Integer to Roman**                                      | `java\nint[] values = {1000,900,500,400,100,90,50,40,10,9,5,4,1};\nString[] symbols = {\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"};\nUse StringBuilder and subtract values while num >= values[i].\n` |
| **LC226 – Invert Binary Tree**                                   | Swap left and right nodes and recursively call `invertTree(root.right)` and `invertTree(root.left)`.                                                                                                                                           |
| **LC104 – Maximum Depth of Binary Tree**                         | Return `1 + Math.max(maxDepth(root.left), maxDepth(root.right))`.                                                                                                                                                                              |
| **LC11 – Container With Most Water**                             | Use left and right pointers. Move the pointer with the smaller height and calculate max area.                                                                                                                                                  |
| **LC42 – Trapping Rain Water**                                   | Maintain `leftMax` and `rightMax`.                                                                                                                                                                                                             |
| **LC141 – Linked List Cycle**                                    | Floyd’s cycle detection algorithm (slow and fast pointers).                                                                                                                                                                                    |
| **LC26 – Remove Duplicates From Sorted Array**                   | If `nums[i] != nums[j]`, assign `nums[i+1] = nums[j]` and increment `i`.                                                                                                                                                                       |
| **LC80 – Remove Duplicates From Sorted Array II**                | Initialize `i = j = 2`. If `nums[i] != nums[j-2]`, assign `nums[j] = nums[i]` and increment `j`.                                                                                                                                               |
| **LC16 – 3Sum Closest**                                          | Sort array. Fix one index and use two pointers. Update closest sum using absolute difference comparison.                                                                                                                                       |
| **LC5 – Longest Palindromic Substring**                          | Expand around center technique.                                                                                                                                                                                                                |
